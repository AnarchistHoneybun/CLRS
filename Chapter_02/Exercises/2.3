1. visual question, refer to page 35

2. Merge(A, p, q, r)
        n1 = q - p + 1
        n2 = r - q
        let L[1..n1] and R[1..n2] be new arrays
    for i = 1 to n1
        L[i] = A[p + i - 1]
    for j = 1 to n2
        R[j] = A[q + j]
    i = 1
    j = 1
    k = p
    while i <= n1 and j <= n2
        if L[i] ≤ R[j]
            A[k] = L[i]
            i = i + 1
        else
            A[k] = R[j]
            j = j + 1
        k = k + 1
    if i > n1
        for x = j to n2
            A[k] = R[x]
            k = k + 1
    else
        for x = i to n1
        A[k] = L[x]
        k = k + 1

3. Base case: when n = 2, T(n) = T(2) = 2. This is equal to 2*lg(2) = 2*1 = 2
    Inductive step: Assume the formula holds for all m such that m<n. 
    For nth value: T(n) = 2T(n/2) + n = 2*(n/2)lg(n/2) + n = n lg(n/2) + n = n lg n - n lg 2 + n = n lg n
    QED

4. T(n) = 1 when n = 1
    T(n) = T(n-1) + n when n > 1

5. Binary search(A, p, r, x):
    if p > r
        return NIL
    q = floor((p + r)/2)
    if A[q] == x
        return q
    else if A[q] > x
        return Binary search(A, p, q-1, x)
    else
        return Binary search(A, q+1, r, x)
    
    For any execution scenario, at any given step, we have to check only in the n/2 elements of an array, where n is the number of elements we have to look amongst after the previous iteration. 
    Since the search space is divided by 2 at each step, the time complexity is Θ(log n)

6. Yes we can achieve a general improvement on running time by using
    binary search instead of linear search when trying to find the position of where to fit the new element, however, the number of swaps required to fit this element in said position would cause the time complexity to still remain Θ(n^2)

7. We can use sorting + two pointer technique for this.
    - Sort the array using merge sort (Θ(n lg n) complexity)
    - Make two pointers, one to the start of array and one to the end. Check sum of both pointers. If sum is less than x, increment lower pointer, and if sum is greater than x, decrement higher pointer. Return true if for some scenario sum of the pointers is x, return false when pointers meet. This has a time complexity of Θ(n) since we iterate over the entire array once.

    This algorithm has a time complexity of Θ(n lg n) + Θ(n) = Θ(n lg n)

