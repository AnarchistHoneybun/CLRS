1. Θ(n^3)

2. SelectionSort(A)
    for i = 1 to A.length - 1
        minIndex = i
        for j = i + 1 to A.length
            if A[j] < A[minIndex]
                minIndex = j
        // Swap A[i] with A[minIndex]
        temp = A[i]
        A[i] = A[minIndex]
        A[minIndex] = temp

    Loop invariant: At the start of each iteration of the outer loop, the subarray A[1..i-1] consists of the i-1 smallest elements of A, in sorted order.

    before execution: i is 1, so i-1 is 0. The subarray A[1..0] is empty, so it trivially consists the 0 smallest elements

    maintenance: say the loop has progressed to i=x. Since for each iteration the algorithm finds the smallest element from i to A.length and swaps with A[i], and then moves to next index, and since previously sorted numbers are not touched again, at any point the subarray A[1..x-1] consists of the x-1 smallest elements of A, in sorted order.

    termination: the program terminates when i = A.length - 1. At this point, the subarray A[1..A.length-2] consists of the A.length-2 smallest elements of A, in sorted order. Since the program has also executed for A[A.length-1], the second last element is also in the correct position. Since all positions have been sorted, the last element is trivially in the correct position.

    The program only needs to run for n-1 elements instead of n, since the last element is trivially in the correct position.

3. On average, half of the elements would have to be checked for any 
    linear search operation, assuming the element is equally likely to be at any position. 
    In the worst case, all of the elements would be checked and the value we are searching for would either be the last element or not in the array.

    Average case run time: Θ(n/2) = Θ(n) <since constants are ignored>
    Worst case run time: Θ(n)

    where n is the input size

4. General modifications to acheive a good best-case running time
    include checking if the search condition is already satisfied, or the array is already sorted and so on. We can also introduce memoization to store the results of previous computations and avoid recomputation in similar scenarios.
